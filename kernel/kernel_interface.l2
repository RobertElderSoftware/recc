OFFSET RELOCATABLE
REQUIRES EXTERNAL globalvar_g_current_sp;
REQUIRES EXTERNAL globalvar_g_kernel_sp;
IMPLEMENTS EXTERNAL task_exit;
IMPLEMENTS EXTERNAL irq_handler;
IMPLEMENTS EXTERNAL kernel_init;
IMPLEMENTS EXTERNAL kernel_exit;
IMPLEMENTS EXTERNAL release_processor;
IMPLEMENTS EXTERNAL block_on_event;
IMPLEMENTS EXTERNAL send_message;
IMPLEMENTS EXTERNAL receive_message;
IMPLEMENTS EXTERNAL reply_message;
REQUIRES EXTERNAL k_task_exit;
REQUIRES EXTERNAL k_irq_handler;
REQUIRES EXTERNAL k_kernel_init;
REQUIRES EXTERNAL k_kernel_exit;
REQUIRES EXTERNAL k_release_processor;
REQUIRES EXTERNAL k_block_on_event;
REQUIRES EXTERNAL k_send_message;
REQUIRES EXTERNAL k_receive_message;
REQUIRES EXTERNAL k_reply_message;
IMPLEMENTS, REQUIRES INTERNAL do_kernel_method;
IMPLEMENTS, REQUIRES INTERNAL exit_kernel_method;
IMPLEMENTS, REQUIRES INTERNAL irq_exit;
IMPLEMENTS, REQUIRES INTERNAL irq_interrupt_chosen;
IMPLEMENTS, REQUIRES INTERNAL method_exit_premption_enabled;
IMPLEMENTS, REQUIRES INTERNAL after_kernel_method_return;
IMPLEMENTS, REQUIRES INTERNAL after_kernel_irq_return;
IMPLEMENTS EXTERNAL init_task_stack;
IMPLEMENTS EXTERNAL or_into_flags_register;

reply_message:
ll r5 k_reply_message;
beq ZR ZR do_kernel_method;

receive_message:
ll r5 k_receive_message;
beq ZR ZR do_kernel_method;

send_message:
ll r5 k_send_message;
beq ZR ZR do_kernel_method;

block_on_event:
ll r5 k_block_on_event;
beq ZR ZR do_kernel_method;

task_exit:
ll r5 k_task_exit;
beq ZR ZR do_kernel_method;

kernel_init:
ll r5 k_kernel_init;
beq ZR ZR do_kernel_method;

kernel_exit:
ll r5 k_kernel_exit;
beq ZR ZR do_kernel_method;

release_processor:
ll r5 k_release_processor;
beq ZR ZR do_kernel_method;

do_kernel_method:
ll r1 0x2;
not r1 r1;       Create a mask to disable global interrupts
and FR FR r1;    Apply the mask.
;--------------- We can no longer be prempted after this point
sub r6 FP SP;    Get bytes of arguments
add r7 r6 ZR;    Make copy for copy counter later
ll r2 method_exit_premption_enabled; We want to restore the PC right after interrupts are enabled in this method
sub SP SP WR;    Increment stack pointer to store PC.
sto SP r2;       Save PC value on stack.
sub SP SP WR;    Increment stack pointer to store FP.
sto SP FP;       Save Frame pointer of the task on stack
sub SP SP WR;    Push stack to store entry method
sto SP ZR;       Store zero to signify that task came from a kernel call
;                ... Save other registers
ll r1 globalvar_g_current_sp;  Save the current task's stack pointer
sto r1 SP;       Save the current SP of the task at kernel function entry
ll r1 globalvar_g_kernel_sp;  Need to switch to kernel sp now
loa SP r1;       Load kernel stack pointer
sub SP SP WR;    Inc another 4 bytes for the return address.
ll r3 after_kernel_method_return;  Get PC value to return point from kernel call
sto SP r3;       Store the return address.
sub SP SP WR;    Push another 4 bytes for the frame pointer.
sto SP ZR;       Save zero for kernel frame pointer
add r1 FP ZR;    Copy FP of user task to copy fcn arguments onto kernel call
beq ZR ZR 5;     Jump to test condition to copy function arguments.  Note:  arguments must be 4-byte objects
sub r1 r1 WR;    Next word
sub SP SP WR;    Next word
loa r2 r1;       Copy the value
sto SP r2;       Store the value
sub r6 r6 WR;    Decrement for count of arguments copied
beq r6 ZR 1;
beq ZR ZR -7;    Go back and copy the next word
add FP SP ZR;    Copy the stack pointer into the frame pointer.
add FP FP r7;    Adjust the FP to account for the arguments we just loaded
add PC ZR r5;    Branch to our kernel method.
after_kernel_method_return:
ll r1 globalvar_g_current_sp;  Load the current task's stack pointer location
loa SP r1;       Load current task's stack pointer
loa r1 SP;       Load the kernel scheduling method
add SP SP WR;    Pop stack to point at FP
beq ZR r1 exit_kernel_method;  If it came from a kernel function call, schedule it the same way
beq ZR ZR irq_exit;   Otherwise it came from an interrupt

exit_kernel_method:
ll r1 globalvar_g_kernel_sp;  Grab ptr to kernel stack
loa r1 r1;       Load ptr of return value from kernel func
loa r2 SP;       Grab frame pointer of task
add r2 r2 WR;    Pointing to return address 
add r2 r2 WR;    Pointing to return value address
sto r2 r1;       Store kernel return value
;                ... Restore other registers
loa FP SP;       Pop Frame pointer
add SP SP WR;    Pop task stack to point at return address
add FR FR WR;    Add 4 to set bit 2 and return from interrupt
;--------------- We can now be prempted again
method_exit_premption_enabled:
add SP FP ZR;    Set stack pointer to frame pointer to get over arguments (save because we just set the FP)
loa FP FP;       Load the previous frame pointer
add SP SP WR;    Jump over the frame pointer to get to the return address
loa r1 SP;       Load the return address
add SP SP WR;    Jump over the return address, which points at the return address space (an int)
add PC ZR r1;    Jump back to the place where the function was called

init_task_stack:
;  SP is currently pointing to param of top argument ptr.
loa r1 SP;       Load function address
add SP SP WR;    Now pointing at param of task SP value
loa r2 SP;       Load address of stack pointer of this task
loa r3 r2;       Get the actual stack pointer variable value.
sto r3 r1;       Store Function address
sub r3 r3 WR;    Push
sto r3 ZR;       Store zero for frame pointer.
sub r3 r3 WR;    Push
sto r3 ZR;       Store zero to signify scheduling as if from kernel call
sto r2 r3;       We updated the stack of this task, save it
add SP SP WR;    Align stack to get FP
loa FP SP;       Load frame pointer
add SP SP WR;    Jump over the frame pointer to get to the return address
loa r1 SP;       Load the return address
add SP SP WR;    Jump over the return address, which points at the return address space (an int)
add PC ZR r1;    Jump back to the place where the function was called

or_into_flags_register:
loa r1 SP;       Load argument value
or FR FR r1;     Or into flags register
add SP SP WR;    Pop argument
loa FP SP;       Load frame pointer
add SP SP WR;    Jump over the frame pointer to get to the return address
loa r1 SP;       Load the return address
add SP SP WR;    Jump over the return address, which points at the return address space (an int)
add PC ZR r1;    Jump back to the place where the function was called

irq_handler:
sub SP SP WR;    Push
sto SP r1;
sub SP SP WR;    Push
sto SP r2;
sub SP SP WR;    Push
sto SP r3;
sub SP SP WR;    Push
sto SP r4;
sub SP SP WR;    Push
sto SP r5;
sub SP SP WR;    Push
sto SP r6;
sub SP SP WR;    Push
sto SP r7;
sub SP SP WR;    Push
sto SP r8;
sub SP SP WR;    Push
sto SP r9;
sub SP SP WR;    Push
sto SP FP;       Save Frame pointer of the task on stack
sub SP SP WR;    Push stack
sto SP WR;       Store 4 to signify that task came from an interrupt
;                Assume UART1 in was asserted
ll r1 0x100;     Bit pattern for bit 8
and r5 r1 FR;    Mask out bit 8
not r1 r5;       Mask to de-assert bit 8
and FR FR r1;    De-assert UART1 in interrupt
beq ZR r5 1;     Skip skipping to end
beq ZR ZR irq_interrupt_chosen;
;                Assume UART1 out was asserted
ll r1 0x40;      Bit pattern for bit 6
and r5 r1 FR;    Mask out bit 6
not r1 r5;       Mask to de-assert bit 6
and FR FR r1;    De-assert UART out interrupt
beq ZR r5 1;     Skip skipping to end
beq ZR ZR irq_interrupt_chosen;
;                Assume timer1 was asserted
ll r1 0x10;      Bit pattern for bit 4
and r5 r1 FR;    Mask out bit 4
not r1 r5;       Mask to de-assert bit 4
and FR FR r1;    De-assert timer1 interrupt
beq ZR r5 1;     Skip skipping to end
beq ZR ZR irq_interrupt_chosen;

irq_interrupt_chosen:
ll r1 globalvar_g_current_sp;  Save the current task's stack pointer
sto r1 SP;       Save the current SP of the task at kernel function entry
ll r1 globalvar_g_kernel_sp;  Need to switch to kernel sp now
loa SP r1;       Load kernel stack pointer
sub SP SP WR;    Inc another 4 bytes for the return address.
ll r3 after_kernel_irq_return;  PC value to return point after irq handler
sto SP r3;       Store the return address.
sub SP SP WR;    Push another 4 bytes for the frame pointer.
sto SP ZR;       Save zero for kernel frame pointer
sub SP SP WR;    For Arg value
sto SP r5;       Store saved assert bits
;sto SP SP;
add FP SP ZR;    Copy the stack pointer into the frame pointer.
add FP FP WR;    Adjust the FP to account for the arguments we just loaded
beq ZR ZR k_irq_handler;    Branch to our kernel method.
after_kernel_irq_return:
ll r1 globalvar_g_current_sp;  Load the current task's stack pointer location
loa SP r1;       Load current task's stack pointer
loa r1 SP;
add SP SP WR;    Pop
beq r1 WR irq_exit;     If we're scheduling a task that came from an interrupt
beq ZR ZR exit_kernel_method;  Happens when scheduling a task that came from kernel call

irq_exit:
loa FP SP;
add SP SP WR;    Pop
loa r9 SP;
add SP SP WR;    Pop
loa r8 SP;
add SP SP WR;    Pop
loa r7 SP;
add SP SP WR;    Pop
loa r6 SP;
add SP SP WR;    Pop
loa r5 SP;
add SP SP WR;    Pop
loa r4 SP;
add SP SP WR;    Pop
loa r3 SP;
add SP SP WR;    Pop
loa r2 SP;
add SP SP WR;    Pop
loa r1 SP;
add SP SP WR;    Pop
add FR FR WR;    Add 4 to set bit 2 and return from interrupt
